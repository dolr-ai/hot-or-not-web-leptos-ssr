use candid::Principal;
use std::{sync::Arc, time::Instant};
use web_time::{Duration, SystemTime};

use anyhow::Context;
use consts::{BACKEND_MODULE_IDENTITY, STDB_URL};
use fasthash::{BufHasher, HasherExt, MetroHasherExt};
use tokio::sync::broadcast;
use yral_spacetime_bindings::{
    autogenerated::backend::{self, mark_airdrop_claimed},
    spacetimedb_sdk::{DbContext, Status, TimeDuration, Timestamp},
};

pub type ReducerResult = Result<(), String>;

/// (input hash, reducer result)
type BusMessage = (u128, ReducerResult);

fn fast_hash<H: std::hash::Hash>(data: H) -> u128 {
    // set constant seed to get consistent result
    let mut hasher = MetroHasherExt::with_capacity_and_seed(0, Some(0));

    data.hash(&mut hasher);

    hasher.finish_ext()
}

/// A wrapper around the [`dedup_index::DbConnection`] with an internal message bus that allows for async operations
#[derive(Clone)]
pub struct WrappedContext {
    pub conn: Arc<backend::DbConnection>,
    tx: broadcast::Sender<BusMessage>,
}

impl WrappedContext {
    pub async fn new(token: Option<impl Into<String>>) -> anyhow::Result<Self> {
        let conn = backend::DbConnection::builder()
            .with_uri(STDB_URL)
            .with_module_name(BACKEND_MODULE_IDENTITY)
            .with_token(token)
            .build()
            .context("Couldn't connect to the db")?;

        let conn = Arc::new(conn);
        let conn_for_ticking = conn.clone();

        // this limit is for lagging mechanism of broadcast channel
        //
        // in our case, the receivers don't any slow work after receiving
        // messages, so we wont run into "slow receiver" problem.
        //
        // however, in case we end up with more than this limit number of
        // requests at the same time, the receiver would fail with error and
        // will most likely be retried by qstash
        let (tx, _) = broadcast::channel(1024);
        let tx_clone = tx.clone();

        conn.reducers.on_mark_airdrop_claimed(
            move |event, user_principal, duration, now, last_airdrop_at| {
                let search_hash = fast_hash(InputData {
                    user_principal: user_principal.clone(),
                    duration: *duration,
                    now: *now,
                    last_airdrop_at: *last_airdrop_at,
                });

                let res = match event.event.status {
                    Status::Committed => Ok(()),
                    Status::Failed(ref msg) => Err(msg.to_string()),
                    Status::OutOfEnergy => Err("Out of energy".into()),
                };

                println!("on mark callback with principal: {user_principal} and res {res:?}");

                // channel must be not be closed
                tx_clone.send((search_hash, res)).unwrap();
            },
        );

        let (trigger_tx, trigger_rx) = tokio::sync::oneshot::channel();
        let start = Instant::now();
        // lets start off with subscribing to everything and then get more precise
        conn.subscription_builder()
            .on_applied(move |_ev| {
                println!("finished subscribing");
                trigger_tx.send(Instant::now()).unwrap();
            })
            .subscribe_to_all_tables();
        println!("subscribing to all stdb tables. this may take a while");

        tokio::spawn(async move {
            let Err(err) = conn_for_ticking.run_async().await else {
                return;
            };

            log::error!("connection to dedup index broke with an error: {err:#?}");
        });

        let end = trigger_rx.await.unwrap();
        println!("subcription took {:?}", end - start);
        Ok(Self { conn, tx })
    }

    pub async fn mark_airdrop_claimed(
        &self,
        user_principal: Principal,
        duration: Duration,
        now: SystemTime,
        last_airdrop_at: Option<impl Into<Timestamp> + Copy>,
    ) -> anyhow::Result<ReducerResult> {
        let search_hash = fast_hash(InputData {
            user_principal: user_principal.to_text(),
            duration: duration.into(),
            now: now.into(),
            last_airdrop_at: last_airdrop_at.map(|t| t.into()),
        });
        let mut rx = self.tx.subscribe();
        self.conn
            .reducers
            .mark_airdrop_claimed(
                user_principal.to_text(),
                duration.into(),
                now.into(),
                last_airdrop_at.map(|t| t.into()),
            )
            .context("Couldn't send reducer request")?;

        let now = Instant::now();
        let res = loop {
            let (recv_hash, data) = rx.recv().await?;
            if recv_hash == search_hash {
                break data;
            }
        };

        println!("reducer took {:?} to mark airdrop", now.elapsed());

        Ok(res)
    }
}

#[derive(Debug, Hash)]
struct InputData {
    user_principal: String,
    duration: TimeDuration,
    now: Timestamp,
    last_airdrop_at: Option<Timestamp>,
}
