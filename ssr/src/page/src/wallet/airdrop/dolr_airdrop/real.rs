use candid::Principal;
use leptos::prelude::*;
use yral_canisters_client::individual_user_template::{Result7, SessionType};
use yral_canisters_common::Canisters;
use yral_spacetime_bindings::{
    autogenerated::backend::DolrAirdropInfoTableAccess,
    spacetimedb_sdk::{TimeDuration, Timestamp},
};

async fn validate_dolr_airdrop_eligibility(
    user_canister: Principal,
    user_principal: Principal,
) -> Result<(), ServerFnError> {
    println!("actually called the damn validator");
    let cans = Canisters::default();
    let user = cans.individual_user(user_canister).await;

    let sess = user.get_session_type().await?;
    if !matches!(sess, Result7::Ok(SessionType::RegisteredSession)) {
        log::error!("Not allowed to claim: not logged in");
        // return Err(ServerFnError::new("Not allowed to claim: not logged in"));
    }

    let ctx: state::stdb_dolr_airdrop::WrappedContext = expect_context();

    let Some(airdrop_info) = ctx
        .conn
        .db
        .dolr_airdrop_info()
        .user_principal()
        .find(&user_principal.to_text())
    else {
        // user has never claimed airdrop before
        return Ok(());
    };

    const DOLR_AIRDROP_LIMIT_DURATION: web_time::Duration =
        web_time::Duration::from_secs(24 * 3600);
    const MAX_AIRDROP_COUNT_WITHIN_DURATION: u64 = 1;

    let now: Timestamp = web_time::SystemTime::now().into();
    let next_airdrop_available_after =
        airdrop_info.last_airdrop_at + TimeDuration::from_duration(DOLR_AIRDROP_LIMIT_DURATION);

    if now < next_airdrop_available_after {
        let count = airdrop_info.airdrop_count_within_duration + 1;
        if count > MAX_AIRDROP_COUNT_WITHIN_DURATION {
            return Err(ServerFnError::new(
                "Not allowed to claim: max claims reached",
            ));
        }
    }

    Ok(())
}

#[server(input = server_fn::codec::Json)]
pub async fn is_user_eligible_for_dolr_airdrop(
    user_canister: Principal,
    user_principal: Principal,
) -> Result<bool, ServerFnError> {
    let res = validate_dolr_airdrop_eligibility(user_canister, user_principal).await;

    match res {
        Ok(_) => Ok(true),
        Err(ServerFnError::ServerError(..)) => Ok(false),
        Err(err) => Err(err),
    }
}

#[server(input = server_fn::codec::Json)]
pub async fn claim_dolr_airdrop(
    user_canister: Principal,
    user_principal: Principal,
) -> Result<u64, ServerFnError> {
    let cans: Canisters<false> = expect_context();
    let user = cans.individual_user(user_canister).await;
    let profile_owner = user.get_profile_details_v_2().await?;
    if profile_owner.principal_id != user_principal {
        // ideally should never happen unless its a hacking attempt
        println!(
            "Not allowed to claim due to principal mismatch: owner={} != receiver={user_principal}",
            profile_owner.principal_id,
        );
        return Err(ServerFnError::new(
            "Not allowed to claim: principal mismatch",
        ));
    }

    validate_dolr_airdrop_eligibility(user_canister, user_principal).await?;

    // send dolr with backend admin
    // update info in stdb

    Ok(100)
}
