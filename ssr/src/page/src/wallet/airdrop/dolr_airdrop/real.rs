use candid::Principal;
use leptos::prelude::*;
use yral_canisters_client::individual_user_template::{Result7, SessionType};
use yral_canisters_common::Canisters;
use yral_spacetime_bindings::{
    autogenerated::backend::DolrAirdropInfoTableAccess,
    spacetimedb_sdk::{TimeDuration, Timestamp},
};

use crate::wallet::airdrop::AirdropStatus;

const DOLR_AIRDROP_LIMIT_DURATION: web_time::Duration = web_time::Duration::from_secs(24 * 3600);
const MAX_AIRDROP_COUNT_WITHIN_DURATION: u64 = 1;

/// returns either ok, or the how long after which airdrop will be available
async fn is_dolr_airdrop_available(
    _user_canister: Principal,
    user_principal: Principal,
    now: web_time::SystemTime,
) -> Result<(), web_time::Duration> {
    let ctx: state::stdb_dolr_airdrop::WrappedContext = expect_context();

    let Some(airdrop_info) = ctx
        .conn
        .db
        .dolr_airdrop_info()
        .user_principal()
        .find(&user_principal.to_text())
    else {
        // user has never claimed airdrop before
        return Ok(());
    };

    let now: Timestamp = now.into();
    let next_airdrop_available_after =
        airdrop_info.last_airdrop_at + TimeDuration::from_duration(DOLR_AIRDROP_LIMIT_DURATION);

    if now < next_airdrop_available_after {
        let count = airdrop_info.airdrop_count_within_duration + 1;
        if count > MAX_AIRDROP_COUNT_WITHIN_DURATION {
            return Err(next_airdrop_available_after
                .duration_since(now)
                .expect("now is less than after"));
        }
    }

    Ok(())
}

#[server(input = server_fn::codec::Json)]
pub async fn is_user_eligible_for_dolr_airdrop(
    user_canister: Principal,
    user_principal: Principal,
) -> Result<AirdropStatus, ServerFnError> {
    let res =
        is_dolr_airdrop_available(user_canister, user_principal, web_time::SystemTime::now()).await;

    match res {
        Ok(_) => Ok(AirdropStatus::Available),
        Err(duration) => Ok(AirdropStatus::WaitFor(duration)),
    }
}

async fn send_airdrop_to_user(_user_principal: Principal) -> Result<(), ServerFnError> {
    println!("sending dolr");

    Ok(())
}

#[server(input = server_fn::codec::Json)]
pub async fn claim_dolr_airdrop(
    user_canister: Principal,
    user_principal: Principal,
) -> Result<u64, ServerFnError> {
    let cans: Canisters<false> = expect_context();
    let user = cans.individual_user(user_canister).await;
    let profile_owner = user.get_profile_details_v_2().await?;
    if profile_owner.principal_id != user_principal {
        // ideally should never happen unless its a hacking attempt
        println!(
            "Not allowed to claim due to principal mismatch: owner={} != receiver={user_principal}",
            profile_owner.principal_id,
        );
        return Err(ServerFnError::new(
            "Not allowed to claim: principal mismatch",
        ));
    }

    let sess = user.get_session_type().await?;
    if !matches!(sess, Result7::Ok(SessionType::RegisteredSession)) {
        log::error!("Not allowed to claim: not logged in");
        // return Err(ServerFnError::new("Not allowed to claim: not logged in"));
    }

    let now = web_time::SystemTime::now();
    if is_dolr_airdrop_available(user_canister, user_principal, now)
        .await
        .is_err()
    {
        return Err(ServerFnError::new(
            "Not allowed to claim: max claims reached within allowed duration",
        ));
    }

    let ctx: state::stdb_dolr_airdrop::WrappedContext = expect_context();

    ctx.mark_airdrop_claimed(user_principal, DOLR_AIRDROP_LIMIT_DURATION, now)
        .await
        .map_err(ServerFnError::new)?
        // this is not likely to happen with current impl on stdb, but good to
        // be cautious
        .map_err(ServerFnError::new)?;

    // sending money _after_ marking claim with reasoning "a couple unhappy users
    // are better than company losing money"
    send_airdrop_to_user(user_principal).await?;

    Ok(100)
}
